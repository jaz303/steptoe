{
	var A = require('./ast');
}

/* Helpers */

_
	= [ \t\r\n]*

ident_start
	= [a-zA-Z_]

ident_rest
	= [a-zA-Z0-9_]

ident
	= $( ident_start ident_rest* )

string
	= "'" chars:string_char_single* "'" { return chars.join(''); }
	/ '"' chars:string_char_double* '"' { return chars.join(''); }

string_char_single
	= escape_char
	/ $ ( !['\\] . )

string_char_double
	= escape_char
	/ $ ( !["\\] . )

escape_char
	= "\\n"		{ return "\n"; }
	/ "\\r"		{ return "\r"; }
	/ "\\t"		{ return "\t"; }
	/ "\\'"		{ return "'"; }
	/ '\\"'		{ return '"'; }
	/ '\\\\'	{ return "\\"; }

/* Tokens */

BREAK 			= "break"		!ident_rest
CONTINUE 		= "continue"	!ident_rest
ELSE 			= "else"		!ident_rest
FALSE 			= "false"		!ident_rest
FUNCTION 		= "function" 	!ident_rest
IF 				= "if"			!ident_rest
NULL 			= "null"		!ident_rest
RETURN 			= "return"		!ident_rest
TRUE 			= "true"		!ident_rest
VAR 			= "var"			!ident_rest
WHILE 			= "while"		!ident_rest

/* Productions */

FunctionDef
	= _ FUNCTION _ name:ident _ params:FunctionParams _ inner:FunctionBlock {
		var fndef = new A.FunctionDef();
		fndef.setName(name);
		fndef.setParams(params);
		fndef.setInnerFunctions(inner.innerFunctions);
		fndef.setVariables(inner.variables);
		fndef.setBody(inner.body);
		return fndef;
	}

FunctionParams
	= '(' _ params:FunctionParamList ')' _ {
		return params;
	}
	/ '(' _ ')' _ {
		return [];
	}

FunctionParamList
	= head:ident _ rest:( ',' _ ident _ )* {
		return [head].concat(rest.map(function(r) {
			return r[2];
		}));
	}

FunctionBlock
	= '{' _ vars:VariableDeclaration* fns:FunctionDef* body:Statements '}' _ {
		return {
			variables 		: vars,
			innerFunctions	: fns,
			body 			: body
		};
	}

VariableDeclaration
	= VAR _ name:ident _ '=' _ initialValue:Expression ';' _ {
		return { name: name, initialValue: initialValue };
	}
	/ VAR _ name:ident _ ';' _ {
		return { name: name };
	}

Statements
	= all:Statement* {
		var stmts = new A.Statements();
		all.forEach(function(s) { stmts.addStatement(s); });
		return stmts;
	}

Statement
	= WhileStatement
	/ IfStatement
	/ BreakStatement
	/ ContinueStatement
	/ ReturnStatement
	/ ExpressionStatement

WhileStatement
	= WHILE _ '(' _ cond:Expression ')' _ body:Block {
		var stmt = new A.WhileStmt();
		stmt.setCondition(cond);
		stmt.setBody(body);
		return stmt;
	}

IfStatement
	= i:IfClause eis:ElseIfClause* e:ElseClause? {
		var stmt = new A.IfStmt();
		stmt.addClause(i);
		eis.forEach(function(c) { stmt.addClause(i); });
		if (e) stmt.addClause(e);
		return stmt;
	}

IfClause
	= IF _ '(' _ exp:Expression ')' _ body:Block {
		return { condition: exp, body: body };
	}

ElseIfClause
	= ELSE _ IF _ '(' _ exp:Expression ')' _ body:Block {
		return { condition: exp, body: body };
	}

ElseClause
	= ELSE _ body: Block {
		return { condition: null, body: body };
	}

Block
	= '{' _ stmts:Statements '}' _ {
		return stmts;
	}

BreakStatement
	= BREAK _ ';' _

ContinueStatement
	= CONTINUE _ ';' _

ReturnStatement
	= RETURN _ exp:Expression _ ';' _ {
		var stmt = new A.ReturnStmt();
		stmt.setReturnValue(exp);
		return stmt;
	}
	/ RETURN _ ';' _ {
		var stmt = new A.ReturnStmt();
		return stmt;
	}

ExpressionStatement
	= exp:Expression _ ';' _ { return exp; }

Expression
	= Array
	/ Object
	/ atom:Atom _ { return atom; }

Array
	= '[' _ exps:ExpressionList ']' _ {
		var ary = new A.ArrayLiteral();
		exps.forEach(function(e) { ary.addExpression(e); });
		return ary;
	}
	/ '[' _ ']' _ {
		return new A.ArrayLiteral();
	}

ExpressionList
	= head:Expression _ rest:( ',' _ Expression )* {
		return [head].concat(rest.map(function(r) { return r[2]; }));
	}

Object
	= '{' _ pairs:Pairs '}' _ {
		var obj = new A.ObjectLiteral();
		pairs.forEach(function(p) {
			obj.addPair(p.key, p.value);
		});
		return obj;
	}
	/ '{' _ '}' _ {
		return new A.ObjectLiteral();
	}

Pairs
	= head:Pair rest:( ',' _ Pair )* {
		return [head].concat(rest.map(function(r) { return r[2]; }));
	}

Pair
	= key:Key _ ':' _ value:Expression {
		return { key: key, value: value };
	}

Key
	= ident
	/ string

Atom
	= Number
	/ String
	/ Boolean
	/ Null
	/ Ident

Number
	= Float
	/ Integer

String
	= str:string { return new A.PrimitiveLiteral(str); }

Float
	= text: $ ( [0-9]+ '.' [0-9]+ ) { return new A.PrimitiveLiteral(parseFloat(text)); }

Integer
	= text: $ ( [1-9] [0-9]* ) { return new A.PrimitiveLiteral(parseInt(text, 10)); }

Boolean
	= TRUE { return new A.PrimitiveLiteral(true); }
	/ FALSE { return new A.PrimitiveLiteral(false); }

Null
	= NULL { return new A.PrimitiveLiteral(null); }

Ident
	= ident:ident { return new A.Ident(ident); }